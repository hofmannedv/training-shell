Der Streameditor `sed`. Erste Schritte.
=======================================
Frank Hofmann
:subtitle:
:doctype: book
:copyright: Frank Hofmann
:revnumber: 1.3.9
:Author Initials: FH
:edition: 1
:lang: de
:date: 6. Juli 2023
:numbered:

= Vorwort =

`sed` steht für Streameditor -- ein Programm, welches einen Datenstrom
mit Hilfe von Filtern verändert. Das beinhaltet bspw. das Löschen,
Suchen und Ersetzen von Zeichenketten auf der Basis von Regulären
Ausdrücken. `sed` sieht erstmal recht einfach aus, ist aber sehr mächtig
und flexibel im Alltagsgebrauch als Filter auf der Kommandozeile und in
Shellskripten.

= Voraussetzungen zum Verständnis =

Um dieses Tutorial zu verstehen, hilft Ihnen das Basiswissen im Umgang
mit der Kommandozeile. Die Kommandos/Werkzeuge `grep`, `vi(m)` und
`less` sollten Ihnen nicht fremd sein. Alle diese Werkzeuge sind in etwa
gleich, unterscheiden sich aber mit Nuancen zueinander.

`sed` benutzt Reguläre Ausdrücke zur Beschreibung von Mustern für
Zeichenketten. Dieses Tutorial setzt grundlegende Kenntnisse von RegEx
voraus. Für ein tieferes Wissen dazu hilft Ihnen das Buch 'Reguläre
Ausdrücke' von Jeffrey Friedl <<Friedl>>.

== Struktur eines Filters ==

Prinzipiell hat ein `sed`-Filter bis zu vier Teile:

----
[Adresse]Aktion/Muster/Ersetzung/Flag
----

Jeder Teil wird durch einen `/` vom nächsten Teil separiert.

* `[Adresse]Aktion`: beschreibt die Zeilen und die Aktion, auf die das
Muster angewendet werden soll, bspw. `i` für `insert` (Zeile einfügen)
und `s` für `substitute` (suchen und ersetzen)
* `Muster`: Beschreibung des Filters als Regulärer Ausdruck (siehe dazu
die Manpage von `REGEX(7)`)
* `Ersetzung`: String, welcher den über das Muster gefundenen Suchtreffer ersetzt
* `Flag`: steuert die Aktion. Es legt fest, was passiert, wenn das Muster zutrifft.

== `sed` als Filter aufrufen ==

`sed` akzeptiert verschiedene Wege, über die es Filter entgegennimmt und
auf den Datenstrom anwendet.

=== Über `stdin` oder als direkten Parameter beim Aufruf von `sed` ===

.Filtern mittels `sed` nach einer Pipe
----
$ cat datei | sed 's/alfred/friedrich/'
----

.Filtern mittels `sed` ohne Pipe und mit direktem Aufruf der Datei
----
$ sed 's/alfred/friedrich/' datei
----

=== `sed`-Skript als separate Datei ===

Die Referenzierung erfolgt über den Schalter `-f` gefolgt von dem Dateinamen
für die Skriptdatei. `GNU sed` versteht auch den langen Schalter `--file`.

.Filtern mittels `sed` und dem Skript `sed.skript`
----
$ sed -f sed.skript datei
----

TIP: Bei den meisten Listings finden Sie in Klammern den Dateinamen des
`sed`-Beispiels. Damit können Sie das Skript sofort ausprobieren.

=== `sed`-Filter als ausführbares Programm ===

Ein `sed`-Skript speichern Sie als separates, ausführbares Programm ab.
Indem Sie der Datei Ausführungsrechte geben, können Sie das Skript wie
ein reguläres Programm aufrufen. Der Aufbau des Skriptdatei folgt dabei
den üblichen Regeln, wie sie bspw. auch bei Perl-, bash- und
Python-Skripten gelten. Nach der obligatorischen, einleitenden
Shebang-Zeile mit dem expliziten Pfad zum ausführenden Interpreter folgt
das `sed`-Programm.

.`sed`-Programm als Skriptdatei (`substitute.sh`)
----
#!/bin/sed -f

s/user fho/benutzer/
----

Geben Sie der obigen Datei Ausführungsrechte via `chmod +x
substitute.sh`, rufen Sie das Skript wie folgt auf der Kommandozeile
auf:

.`sed`-Programm als Skript aufrufen
----
$ ./substitute.sh logfile 
2016-01-10 10:45:15 benutzer logged in on /dev/tty1
2016-01-11 08:30:10 benutzer logged in on /dev/tty2
...
$
----

== Mehrere Filter miteinander kombinieren ==

Manchmal ist es einfacher, mehrere kleine Filter zu formulieren, als
sich einen einzigen, komplexen Regulären Ausdruck auszudenken. `sed`
kennt mehrere Varianten zur Verkettung der Filter. Hierbei werden die
einzelnen Anweisungen (Filter) in der Reihenfolge von `sed` verarbeitet,
wie sie im Aufruf genannt sind. 

In den nachfolgenden Beispielen wird im ersten Schritt `alfred` durch
`friedrich` ersetzt, und danach alle Vorkommen von `Holger` (mit großem
und kleinem `h`) durch `michael`. Die Ausgabe erfolgt auf `stdout`.

=== Einzelne Filter voneinander über ein Semikolon trennen ===

Im Aufruf geben Sie zwischen den einzelnen Filtern jeweils ein `;` als
Trennzeichen an. Bitte beachten Sie, dass das Trennzeichen innerhalb der
einfachen Anführungszeichen (`'`) steht.

.Mehrere Filter mittels `;` aneinanderreihen
----
$ sed 's/alfred/friedrich/; s/[Hh]olger/michael/' datei
----

TIP: `[Hh]` beinhaltet einen Regulären Ausdruck für den einzelnen
Buchstaben `h` in Groß- oder Kleinschreibung.

=== Jeden Filter mit `-e` einleiten ===

Über den Schalter `-e` teilen Sie `sed` mit, dass ein weiterer Filter
folgt. `GNU sed` versteht auch den langen Schalter `--expression`.

.Mehrere Filter mittels `-e` aneinanderreihen
----
$ sed -e 's/alfred/friedrich/' -e 's/[Hh]olger/michael/' datei
----

=== Die Fähigkeiten der bash ausnutzen (mehrere Zeilen) ===

Je komplexer die Filter werden, umso unübersichtlicher werden diese
auch. Sie können die einzelnen Filter auch über mehrere Zeilen
verteilen, indem Sie im Aufruf ein `\` als expliziten Zeilenumbruch
einfügen.

.Jeden Filter in einer einzelnen Zeile
----
$ echo "apple banana" | sed -e 's/a/A/g' \
> -e 's/e/E/g'
ApplE bAnAnA
$
----

== Die Ausgabe steuern ==

Im Standardfall gibt `sed` alle Zeilen des Eingabedatenstroms aus. Um
das zu unterdrücken, nutzen Sie den Schalter `-n` (Langform `--quiet`
und `--silent`). Von Nutzen ist `-n`, um nur die Zeilen der Eingabe
ausgeben, in denen ihr Filter tatsächlich Veränderungen bewirkt hat.
Dazu schließen Sie den Filter mit dem Flag `p` für `print` am Ende ab:

.Lediglich die Ersetzungen ausgeben
----
$ sed -n 's/alfred/friedrich/p' datei
----

Diese Vorgehensweise funktioniert auch bei der Aneinanderreihung von
mehreren `sed`-Skripts, selbst wenn einer der anderen Filter nicht
zutrifft.

.Veränderungen bei mehreren Filtern ausgeben
----
$ echo holger | sed -n 's/alfred/friedrich/p; s/[Hh]olger/michael/p' 
michael
$
----

== Beispiele ==

=== Ausgeben einer Datei ===

Die nachfolgenden Aufrufe haben ihre Entsprechung in den
UNIX/Linux-Kommandos `cat`, `tac`, `head` und `tail`. Das Kommando `nl`
kommt nur zum Einsatz, um eine Zeilennummer zu ergänzen und die Wirkung
des `sed`-Kommandos besser zu zeigen.

Das Ausgeben einer betreffenden Zeile erfolgt mit dem Aktionsparameter
`p` für `print`.

.Den gesamten Inhalt einfach ausgeben (`output-content.sed`)
----
$ nl logfile | sed -n 'p'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die vierte Zeile ausgeben (`output-content-line4.sed`)
----
$ nl logfile | sed -n '4p'
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
$
----

.Alles außer der vierten Zeile ausgeben (`output-content-without-line4.sed`)
----
$ nl logfile | sed -n '4!p'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die Zeilen vier bis sechs ausgeben (`output-content-line4-6.sed`)
----
$ nl logfile | sed -n '4,6p'
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
$
----

.Ab Zeile 7 bis zum Dateiende ausgeben (`output-content-line7-end.sed`)
----
$ nl logfile | sed -n '7,$p'
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Zeilen löschen ===

Das Löschen einer betreffenden Zeile erfolgt mit dem Aktionsparameter
`d` für `delete`.

.Alle Zeilen löschen (`delete-content.sed`)
----
$ nl logfile | sed -n 'd'
$
----

.Lediglich die dritte Zeile löschen (`delete-content-line3.sed`)
----
$ nl logfile | sed '3d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Die Zeilen 3 bis 5 löschen (`delete-content-line3-5.sed`)
----
$ nl logfile | sed '3,5d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die erste und die letzte Zeile löschen (`delete-content-first-and-last-line.sed`)
----
$ nl logfile | sed '1d;$d'
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
$
----

.Alles von der ersten Zeile bis einschließlich der Zeile löschen, die das Suchmuster `2016-01-11` beinhaltet (`delete-content-first-up-to-match.sed`)
----
$ nl logfile | sed '1,/2016-01-11/d'
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Alles bis zum Ende ab der Zeile löschen, die das Suchmuster `2016-01-11` enthält (`delete-content-match-to-the-end.sed`)
----
$ nl logfile | sed '/2016-01-11/,$d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
$
----

.Lösche die erste Zeile nur dann, wenn diese das Suchmuster `2016-01-10` enthält (`delete-content-first-only-with-match.sed`)
----
$ nl logfile | sed '1{/2016-01-10/d;}'
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Lösche die entsprechenden Zeilen aus den Zeilen 1 bis 5 nur, wenn diese entweder das Suchmuster `2016-01-11` oder `2016-01-12` beinhalten (`delete-content-with-match.sed`)
----
$ nl logfile | sed '1,5{/2016-01-1[12]/d;}' 
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Zeilen einfügen ===

==== Vor dem Suchtreffer ====

Das Anfügen von Inhalt nach einer betreffenden Zeile erfolgt mit dem
Aktionsparameter `a` für `append`. `GNU sed` versteht dafür die
einzeilige Notation `/a++++` und `/a\++++`. `BSD sed` ist pedantischer
und erwartet nach dem Aktionsparameter einen Zeilenumbruch.

.Vier `+` nach (jedem) Eintrag einfügen, der `2016-01-10` beinhaltet (`insert-after-pattern.sed`)
----
$ nl logfile | sed '/2016-01-10/a\
++++'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Optische Trennung zwischen Datumswechseln (Einfügen nach dem Suchtreffer)
----
$ nl logfile | sed -e '/2016-01-10/a++++ 2016-01-11 ++++' -e '/2016-01-11/a++++ 2016-01-12 ++++'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++++ 2016-01-11 ++++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
++++ 2016-01-12 ++++
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

Obiges Beispiel funktioniert nur mit `GNU sed`. Um es kompatibel für
`BSD sed` zu halten, bedarf es eines expliziten Umbruchs:

----
$ nl logfile | sed -e '/2016-01-10/a\
++++ 2016-01-11 ++++' -e '/2016-01-11/a\
++++ 2016-01-12 ++++'
$
----

Hierbei besteht die Gefahr, dass die Übersicht im Aufruf verloren geht.
Die Empfehlung ist, zunächst eine Musterdatei mit den beiden Suchmustern
(siehe `insert-after-with-more-patterns.sed`) zu erzeugen. Die mit `-e`
getrennten Muster/Aktionen werden in der Anweisungsdatei einfach durch
Leerzeilen voneinander getrennt.

==== Nach dem Suchtreffer ====

Das Einfügen von Inhalt vor einer betreffenden Zeile erfolgt mit dem
Aktionsparameter `i` für `insert`. `GNU sed` versteht dafür die
einzeilige Notation `/i++++` und `/i\++++`. `BSD sed` ist pedantischer
und erwartet nach dem Aktionsparameter einen Zeilenumbruch.

.Markieren aller erfolgreichen Logins des Benutzers `fho` (`insert-before-pattern.sed`)
----
$ nl logfile | sed -e '/fho logged in/i++ fho ++'
++ fho ++
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++ fho ++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
++ fho ++
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Finde alle Zeilen der Eingabe, welches ein bestimmtes Muster beinhalten ===

Die nachfolgenden Aufrufe sind ähnlich zu `grep`, `vi` und `less`, wobei
hier die Verwandschaft der drei Werkzeuge deutlich wird. Beachten Sie
bei der Benutzung aber die leichten syntaktischen Unterschiede. Ob sie
im Alltag zur Lösung Ihres Problems auf `grep`, `sed` oder `awk`
zurückgreifen, ist häufig eine Frage der Gewohnheit und mit welchem
Aufwand Sie das Problem lösen können.

.Alle Zeilen der Datei `logfile` ausgeben, die das Muster `fho` enthalten (`print-content.sed`)
----
$ sed -n '/fho/p' logfile
2016-01-10 10:45:15 user fho logged in on /dev/tty1
2016-01-11 08:30:10 user fho logged in on /dev/tty2
2016-01-12 08:46:45 user fho logged in on /dev/pty1
2016-01-12 12:13:10 user fho logged out from /dev/pty1
$
----

.Suche alle Zeilen, die entweder auf 44 oder 45 enden (`print-content-regex.sed`)
----
$ sed -n '/4[45]$/p' logfile
2016-01-12 14:45:12 login failed for user root from 10.10.17.44
2016-01-12 14:46:10 login failed for user root from 10.10.17.45
2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

`GNU sed` hat eine zusätzliches Aktionsflag namens `I`. Dieses steht für
'case insensitive', d.h. unabhängig von Groß- und Kleinschreibung. Damit
vereinfacht sich die Schreibweise im Aufruf wie folgt:

.Suche nach dem Vorkommen des Musters `banana` unabhängig von Groß- und Kleinschreibung (`print-content-case-ins.sed`)
----
$ echo "Apple Banana banana" | sed -n '/banana/Ip' 
Apple Banana banana
$
----

TIP: das Aktionsflag `I` gibt es nicht bei allen `sed`-Varianten.

=== Zeilennummern der Suchtreffer ===

Um nur die Zeilennummern der Treffer zu erhalten, in denen das
Suchmuster enthalten ist, hilft Ihnen der Schalter `=`.

.Ausgabe der Zeilennummern der Zeilen, in denen das Muster enthalten ist (`print-match-line-numbers.sed`)
----
$ sed -n '/fho/ =' logfile
1
2
4
5
$
----

=== Suchen und Ersetzen nach einem Muster in ausgewählten Zeilen und Unterdrücken der Zeilen, die dem Muster nicht entsprechen ===

.Ersetze nur in Zeile 9 alle Vorkommen von `root` durch `alex` (`replace-in-line.sed`)
----
$ sed -n '9s/root/alex/p' logfile
2016-01-12 14:57:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` ab Zeile 6 bis zum Ende (`replace-in-line-to-the-end.sed`)
----
$ sed -n '6,$s/root/alex/p' logfile
2016-01-12 14:45:12 login failed for user alex from 10.10.17.44
2016-01-12 14:46:10 login failed for user alex from 10.10.17.45
2016-01-12 14:57:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` in den Zeilen 4 bis 7 (`replace-in-line4-7.sed`)
----
$ sed -n '4,7s/root/user/p' logfile
2016-01-12 14:45:12 login failed for user alex from 10.10.17.44
2016-01-12 14:46:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` außerhalb der Zeilen 4 bis 7 (`replace-outside-line4-7.sed`)
----
$ nl logfile | sed -n '4,7!s/root/user/p'
     9   2016-01-12 14:57:10 login failed for user user from 10.10.17.45
$
----

.Ersetze alle Vorkommen der IP-Adresse `10.10.17.45` durch den Hostnamen `supercomputer` in allen Zeilen des Logfiles, in denen die Zeichenkette `2016-01-12` enthalten ist
----
$ nl logfile | sed -n '/2016-01-12/s/10\.10\.17\.45/supercomputer/p'
     7   2016-01-12 14:46:10 login failed for user root from supercomputer
     9   2016-01-12 14:57:10 login failed for user root from supercomputer
$
----

TIP: Beachten Sie die besondere Schreibweise von `\.`. Ein Punkt ist ein
Metazeichen im RegEx-Patternmatching und trifft auf jedes beliebige
Zeichen zu. Dank dem vorangestellten Escape-Zeichen `\` matcht lediglich
ein echter Punkt (`.`).

=== Suchen und Ersetzen nach Vorkommen ===

`sed` kennt verschiedene Varianten, um Suchmuster zu ersetzen. Die
jeweilige Variante spezifizieren Sie über das Aktionsflag im letzten
Segment des Suchen-und-Ersetzen-Ausdrucks.

==== Nur das erste Vorkommen ersetzen ====

Geben Sie kein Aktionsflag an, ersetzt `sed` nur den ersten Suchtreffer
in der Zeile:

.Ersetze das erste Vorkommen von `apple` durch `banana`
----
$ echo "apple orange melon apple" | sed 's/apple/banana/'
banana orange melon apple
$
----

TIP: Dieser Aufruf ist identisch mit `sed 's/apple/banana/1'`, d.h. der
expliziten Referenzierung des ersten Suchtreffers mittels `1`.

==== Alle Vorkommen ersetzen ====

Um alle Vorkommen des Suchmusters in der Zeile zu ersetzen, verwenden
Sie das Aktionsflag `g` für `global`.

.Ersetze alle Vorkommen von `apple` durch `banana`
----
$ echo "apple orange melon apple" | sed 's/apple/banana/g'
banana orange melon banana
$
----

==== Einen ausgewählten Suchtreffer ersetzen ====

`sed` zählt, wieviele Suchtreffer es gibt. Es erlaubt Ihnen, über die
entsprechenden Ziffer den jeweiligen Suchtreffer zu referenzieren. Im
nachfolgenden Beispiel wird nur der zweite Suchtreffer ersetzt und alle
anderen bleiben unverändert:

.Ersetze nur das zweite Vorkommen von `apple` durch `banana`
----
$ echo "apple orange melon apple" | sed 's/apple/banana/2'
apple orange melon banana
$
----

==== Einen ausgewählten Suchtreffer ab einer Position ersetzen ====

`sed` erlaubt Ihnen, auch alle Suchtreffer ab einer Position zu
ersetzen. Dazu versteht es bspw. die Schreibweise `2g` für eine globale
Ersetzung ab dem zweiten Vorkommen des Suchmusters:

.Ersetze ab dem zweiten Vorkommen jedes Mal `apple` durch `banana`
----
$ echo "apple orange melon apple apple" | sed 's/apple/banana/2g'
apple orange melon banana banana
$
----

==== Eine komplette Zeile ersetzen ====

Das Aktionsflag `c` für `change` ändert bzw. ersetzt eine Zeile
vollständig durch den darauffolgenden Text, sofern diese das gewünschte
Suchmuster enthält. Im nachfolgenden Beispiel werden alle Zeilen, die
das Muster `login failed` enthalten, auf den Inhalt `login failed`
gekürzt.

.Ersetze eine komplette Zeile
----
$ nl logfile | sed -e '/login failed/clogin failed'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
login failed
login failed
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
login failed
$
----

=== Zeichen zu jeder Zeile hinzufügen ===

Die Metazeichen `^` und `$` sind auf den Anfang und das Ende der Zeile
anwendbar. Damit fügen Sie flink Text zu einer Zeile hinzu.

==== Am Anfang jeder Zeile ====

.Den Buchstaben `A` am Zeilenanfang ergänzen
----
$ echo abc | sed -n 's/^/A/p'
Aabc
$
----

==== Am Ende jeder Zeile ====

.Den Buchstaben `B` am Zeilenende ergänzen
----
$ echo abc | sed -n 's/$/B/p'
abcB
$
----

Das ganze schreiben Sie mit nachfolgendem Aufruf kürzer. Dabei erfolgen
nur Ersetzungen, anstatt zu prüfen, ob es einen Match gibt. `$` matcht
stets auf das Zeilenende jeder einzelnen Zeile.

.Den Buchstaben `B` am Zeilenende ergänzen
----
$ echo abc | sed -e 's/$/B/'
abcB
$
----

Dass das auch mit mehreren Zeilen funktioniert, zeigt nachfolgender
Codeausschnitt:

.Den Buchstaben `B` am Zeilenende ergänzen (mehrzeilig)
----
$ (echo abc; echo ) | sed -e 's/$/B/'
abcB
B
$
----

=== Spaltenweise agieren ===

Die nachfolgend vorgestellten Aktionen sind Sonderfälle für das vorige
Kapitel. Im Alltag kommen diese häufig vor.

==== Spalte entfernen ====

.Entferne die erste Spalte (Trennzeichen: `:`) in den Zeilen 1 bis 10 der Datei `/etc/passwd` (ersetze alles bis zum ersten `:` durch nichts)
----
$ sed -n '1,10s/[^:]\+://p' /etc/passwd
x:0:0:root:/root:/bin/bash
x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
x:2:2:bin:/bin:/usr/sbin/nologin
x:3:3:sys:/dev:/usr/sbin/nologin
x:4:65534:sync:/bin:/bin/sync
x:5:60:games:/usr/games:/usr/sbin/nologin
x:6:12:man:/var/cache/man:/usr/sbin/nologin
x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
x:8:8:mail:/var/mail:/usr/sbin/nologin
x:9:9:news:/var/spool/news:/usr/sbin/nologin
$
----

TIP: Obiges Beispiel gelingt problemlos auf einem Linux-System. Auf
einem OS X oder BSD kann es schiefgehen, wenn die Datei mit
Kommentarzeichen `#` beginnt.

.Nur die erste Spalte ausgeben, Trennzeichen ist `:` (entspricht `cut -d: -f1 /etc/passwd`)
----
$ sed -n '1,10s/:.*$//p' /etc/passwd
root
daemon
bin
sys
sync
games
man
lp
mail
news
$
----

TIP: Auf einem Mac OS X sind die ersten 10 Zeilen der Datei
`/etc/passwd` mit Kommentarzeichen versehen. Deshalb ist auf einem
solchen System die Ausgabe dieses Beispiels leer.

==== Eine Spalte am Anfang hinzufügen ====

.Eine weitere Spalte am Anfang hinzufügen (Inhalt: `A`)
----
$ sed -n '1,10s/.*/A:&/p' /etc/passwd
A:root:x:0:0:root:/root:/bin/bash
A:daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
A:bin:x:2:2:bin:/bin:/usr/sbin/nologin
A:sys:x:3:3:sys:/dev:/usr/sbin/nologin
A:sync:x:4:65534:sync:/bin:/bin/sync
A:games:x:5:60:games:/usr/games:/usr/sbin/nologin
A:man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
A:lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
A:mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
A:news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
$
----

Obiges Beispiel zielt auf die Verwendung von `&`, um Zeichenketten
aneinanderzufügen. Kürzere Varianten wären:

----
$ sed -n '1,10s/^/A:/p' /etc/passwd
----

Die Idee dahinter ist, den Zeilenanfang (`^`) durch die beiden Zeichen
`A:` zu ersetzen. Da der Doppelpunkt in der Datei als Spaltentrenner
gilt, ist dieser Schritt defacto das Ergänzen der Datei um eine weitere
Spalte am Anfang jeder Zeile.

Da im Muster ohnehin jede Zeile matcht (`-n` gibt nur die matchenden
Zeilen mit `p` aus), geht auch diese Variante und ist nochmals kürzer
als oben:

----
$ sed -e 's/1,10s/^/A:/' /etc/passwd
----

==== Eine Spalte am Ende hinzufügen ====

.Eine weitere Spalte am Ende hinzufügen (Inhalt: `B`)
----
$ sed -n '1,10s/.*/&:B/p' /etc/passwd
root:x:0:0:root:/root:/bin/bash:B
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin:B
bin:x:2:2:bin:/bin:/usr/sbin/nologin:B
sys:x:3:3:sys:/dev:/usr/sbin/nologin:B
sync:x:4:65534:sync:/bin:/bin/sync:B
games:x:5:60:games:/usr/games:/usr/sbin/nologin:B
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin:B
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin:B
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin:B
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin:B
$
----

In Anlehnung an das vorherige Beispiel ist diese Schreibweise wiederum
kürzer. Es setzt ebenso darauf auf, das Zeilenende (`$`) durch die
beiden Zeichen `:B` zu ersetzen, was wiederum der Ergänzung um eine
weitere Spalte am Ende der Zeile gleichkommt.

----
$ sed -e '/1,10s/$/:B/p' /etc/passwd
----

=== Suchtreffer referenzieren ===

`sed` erlaubt Ihnen, die einzelnen Suchtreffer zu referenzieren. Dazu
kennt es die beiden Metazeichen `&` und `\ZAHL` (siehe Hinweis). Mittels
`\1` verweisen Sie auf den ersten Suchtreffen, mittels `\2` auf den
zweiten etc.

==== Suchtreffer markieren ====

Das nächste Beispiel fokussiert lediglich auf den ersten Suchtreffer und
faßt den in der Ausgabe beispielhaft in runde Klammern ein.

.Markiere nur den ersten Suchtreffer mit runden Klammern (Referenz mittels `&`)
----
$ echo "apple orange melon apple Apple" | sed 's/[Aa]pple/(&)/'
(apple) orange melon apple Apple
----

Möchten Sie alle Suchtreffer berücksichtigen, ergänzen Sie den
`sed`-Aufruf um das Aktionsflag `g` am Ende des Ausdrucks:

.Markiere jeden Suchtreffer mit runden Klammern (Referenz mittels `&`)
----
$ echo "apple orange melon apple Apple" | sed 's/[Aa]pple/(&)/g'
(apple) orange melon (apple) (Apple)
$
----

==== Suchtreffer in anderer Reihenfolge ausgeben ====

Das Konzept der Regulären Ausdrücke beinhaltet sogenannte 'back
references' ("Rückverweis"). Jedem einzelnen Suchtreffer wird eine
Ziffer zugeordnet, über die Sie dann auf den jeweiligen Suchtreffer
zugreifen können. Den ersten Suchtreffer referenzieren Sie bei `sed`
mittels `\1`, den zweiten mittels `\2`, etc. Dieses Konzept nutzen Sie
in nachfolgendem Beispiel, um Suchtreffer 1 und 2 in einer umgekehrten
Reihenfolge auszugeben.

.Den ersten und zweiten Suchtreffer in umgekehrter Reihenfolge ausgeben ('back references')
----
$ echo "10247 Berlin" | sed -n 's/\([0-9]\+\) \([A-Za-z]\+\)/\2, \1/p'
Berlin, 10247
$
----

Um das ganze sowohl für `GNU sed`, als auch für `BSD sed` nutzbar zu
machen, benötigen Sie den zusätzlichen Schalter `-E` im Aufruf von
`sed`. Damit aktivieren Sie einen Modus für erweiterte Reguläre
Ausdrücke ('extended regular expressions'). Als Ergebnis vereinfacht
sich ebenfalls der gesamte Ausdruck.

.Den ersten und zweiten Suchtreffer in umgekehrter Reihenfolge ausgeben (kompatibel)
----
$ echo "10247 Berlin" | sed -E -n 's/([0-9]+) ([A-Za-z]+)/\2, \1/p'
Berlin, 10247
$
----

TIP: Zum Grübeln: was erwarten Sie für eine Ausgabe bei dem folgenden
`sed`-Aufruf:

----
$ echo "10247 23 Berlin" | sed -E -n 's/([0-9]+) ([A-Za-z]+)/\2, \1/p'
----

==== Beispiel: Datum in das ISO-Format umwandeln ====

Um ein Datum in das ISO-Format der Form JJJJ-MM-TT zu überführen, bietet
sich dieser Aufruf an. Es sortiert zunächst Tag, Monat und Jahr in die
Reihenfolge für das ISO-Format und schaut danach, ob Monat und Tag eine
führende Null besitzen. Falls nicht vorhanden, wird diese ergänzt:

.Datum in das ISO-Format umwandeln ('replace-date.sed')
----
$ echo "1-7-2016" | sed -nr -e 's/([[:digit:]]{1,2})-([[:digit:]]{1,2})-([[:digit:]]{4})/\3-\2-\1/p' -e 's/-([[:digit:]])-/-0\1-/p' -e 's/-([[:digit:]])$/-0\1/p'
2016-7-1
2016-07-1
2016-07-01
$
----

Möchten Sie nur die letzte Zeile als Ergebnis haben, kommen die
Buchstaben zur Steuerung der Ausgabe ins Spiel. Die ersten beiden
Ausdrücke erhalten ein 'g' anstatt dem 'p', so dass nur die letzte
Modifikation der Zeichenkette gedruckt wird:

.Datum in das ISO-Format umwandeln
----
$ echo "1-7-2016" | sed -nr -e 's/([[:digit:]]{1,2})-([[:digit:]]{1,2})-([[:digit:]]{4})/\3-\2-\1/g' -e 's/-([[:digit:]])-/-0\1-/g' -e 's/-([[:digit:]])$/-0\1/p'
2016-07-01
$
----

Beinhaltet ihre Zeichenkette Punkte und Schrägstriche, wie es bspw. in
Deutschland und Frankreich üblich ist (`1.7.2016`), helfen Ihnen die
folgenden vier Ausdrücke weiter:

.Datum in das ISO-Format umwandeln -- mit Sonderzeichen
----
s/[\.\/]/-/g
s/([[:digit:]]{1,2})-([[:digit:]]{1,2})-([[:digit:]]{4})/\3-\2-\1/g
s/-([[:digit:]])-/-0\1-/g
s/-([[:digit:]])$/-0\1/p
----

=== Klammern entfernen oder ersetzen ===

Klammern haben in regulären Ausdrücken eine besondere Bedeutung, bspw.
`[abc]` steht für die Auswahl einer der Buchstaben `a`, `b` oder `c`.
Diese speziellen Zeichen zu entfernen oder zu ersetzen, kann mitunter
etwas umständlich zu formulieren sein und ist nicht unbedingt immer
sofort lesbar.

Alle schließenden Klammern (`]`) entfernen Sie wie im folgenden
Beispiel. Der Aktionsparameter `g` sorgt dafür, daß alle Vorkommen
berücksichtigt werden.

.Alle schließenden, eckigen Klammern entfernen
----
$ echo "[Haus] [Boot]" | sed -e 's/\]//g'
[Haus [Boot
$
----

Mit einem analogen `sed`-Aufruf ersetzen Sie auch die öffnende Klammer
(`[`). Eleganter wäre es, beide Klammern in einem einzigen Aufruf zu
ersetzen. Nachfolgender Ausdruck ermöglicht das:

.Alle öffnenden und schließenden, eckigen Klammern entfernen
----
$ echo "[Haus] [Boot]" | sed -e 's/[][]//g'
Haus Boot
$
----

Der RegEx-Interpreter ist recht 'gierig' und interpretiert alle Zeichen
zwischen den äußeren beiden Klammern als mögliche Zeichen. Wem das zu
unverständlich ist, kann auch zwei einfachere Ausdrücke "in Reihe
schalten". Zunächst werden im ersten Ausdruck alle öffnenden Klammern
entfernt, im zweiten Ausdruck alle schließenden Pendants:

.Alle öffnenden und schließenden, eckigen Klammern entfernen (Version 2)
----
$ echo "[Haus] [Boot]" | sed -e 's/\[//g' -e 's/\]//g'
Haus Boot
$
----

Eine Alternative stellen erweiterte Reguläre Ausdrücke ('extended
regular expressions') dar. Dafür geben Sie den zusätzlichen Schalter
`-E` oder `-r` im `sed`-Aufruf an. `sed` unter OS X kennt den Schalter
`-r` nicht, hier nutzen Sie stattdessen `-E`.

Das nachfolgende Beispiel ersetzt eine Buchreferenz in eckigen Klammern
durch einen Stern mit Leerzeichen (öffnende Klammer) und einen
Doppelpunkt (schließende Klammer).

.Eckige Klammern referenzieren und ersetzen
----
$ echo "[12] Buchreferenz" | sed -rn 's/(\[)(.+)(\])/* \2\)/p'
* 12) Buchreferenz
$
----

Sind die Referenzen auf die Klammern nicht erforderlich, vereinfacht
sich das ganze zu folgendem:

.Eckige Klammern referenzieren und ersetzen (vereinfacht)
----
$ echo "[12] Buchreferenz" | sed -rn 's/\[(.+)\]/* \1\)/p'
* 12) Buchreferenz
$
----

=== Alle leeren Zeilen aus der Eingabe herausfiltern ===

Hier werden zwei Dinge miteinander kombiniert -- ein Muster, und eine
Aktion. Das Muster für eine leere Zeile ist `^$`, und das Löschen einer
Zeile erfolgt über das Aktionsflag `d`.

.Muster `^$` für leere Zeilen, `d` zum Löschen (`delete-empty-lines-1.sed`)
----
$ sed '/^$/d' logfile-with-empty-lines
2016-01-10 10:45:15 user fho logged in on /dev/tty1
2016-01-11 08:30:10 user fho logged in on /dev/tty2
2016-01-12 08:45:12 user james logged in on /dev/tty1
2016-01-12 08:46:45 user fho logged in on /dev/pty1
2016-01-12 12:13:10 user fho logged out from /dev/pty1
2016-01-12 14:45:12 login failed for user root from 10.10.17.44
2016-01-12 14:46:10 login failed for user root from 10.10.17.45
2016-01-12 14:55:05 user james logged out from /dev/tty1
2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

Alternativ löschen Sie mit dem folgenden Aufruf alle Zeilen, die nicht
leer sind (doppelte Verneinung). Der Punkt im Suchmuster trifft auf alle
Zeilen zu, die mindestens ein Zeichen beinhalten. Der Aktionsparameter
`!d` löscht die Zeilen nicht, auf die das Suchmuster zutrifft.

.Muster `.` für nicht-leere Zeilen, `!d` um diese nicht zu entfernen (`delete-empty-lines-2.sed`)
----
$ sed '/./!d' logfile-with-empty-lines
2016-01-10 10:45:15 user fho logged in on /dev/tty1
2016-01-11 08:30:10 user fho logged in on /dev/tty2
2016-01-12 08:45:12 user james logged in on /dev/tty1
2016-01-12 08:46:45 user fho logged in on /dev/pty1
2016-01-12 12:13:10 user fho logged out from /dev/pty1
2016-01-12 14:45:12 login failed for user root from 10.10.17.44
2016-01-12 14:46:10 login failed for user root from 10.10.17.45
2016-01-12 14:55:05 user james logged out from /dev/tty1
2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

Zu diesen `sed`-Aufrufen besteht ein passendes Pendant bei dem
UNIX-Kommando `grep`. Es wird erreicht über den Schalter `-v`, der die
Suche invertiert. Der entsprechende Aufruf des UNIX-Kommandos `grep` ist
wie folgt:

.Invertierte Suche mittels `grep`:
----
$ grep -v '^$'  logfile-with-empty-lines
----

=== Den ersten Absatz ausgeben ===

.Alle Zeilen inklusive der ersten Leerzeile ausgeben (`print-first-paragraph.sed`)
----
$ sed -n '1,/^$/p' logfile-with-empty-lines
2016-01-10 10:45:15 user fho logged in on /dev/tty1

$
----

=== Shell-Variablen übernehmen ===

Benötigen Sie den Wert einer Shellvariable in ihrem sed-Aufruf,
benötigen Sie dazu keine weiteren Schalter und übernehmen die Variable
direkt. Das nachfolgende Beispiel basiert auf einem Logfile mit
Einträgen aus Zeitstempel und Aufruf. Das Ziel besteht darin, alle
Fehler aus dem Logfile herauszufiltern und nur die Einträge anzuzeigen,
die zu dem genannten Datum passen.

Verknüpft werden zwei Tests miteinander: Test 1 löscht mittels
`/^.*ERROR.*$/d` alle Zeilen, die den Wert `ERROR` beinhalten. Dabei 
spielt die Position des Wertes keine Rolle. Test 2 prüft, ob in der 
Zeile der Inhalt des ersten Aufrufparameters des Shellskripts vorkommt.
Nur die Zeilen erscheinen in der Ausgabe, die übrig bleiben.

.Variablen aus der Shell übernehmen (`filter.sh`)
----
#!/bin/bash

sed -E -n -e '/^.*ERROR.*$/d' -e "/$1/p"
----

Der Aufruf in der Shell sieht wie folgt aus:

.Aufruf von der Shell aus
----
$ echo -e "Mo 12 Okt ping\nDi 13 Okt ERROR\nDi 13 Okt pong\nMi 14 Okt ping" | ./filter.sh "13 Okt"
Di 13 Okt pong
$
----

Gesucht wird hier nach allen Einträgen im Logfile, die das Datum `13
Okt` tragen. Zunächst werden drei Zeilen gefunden, aus denen lediglich 
die Zeile `Di 13 Okt pong` übrig bleibt.

== Einen Dateiinhalt direkt ändern ==

=== Ohne Backupdatei ===

`GNU sed` unter Linux verfügt über den Schalter `-i` für 'inline edit'.
Damit ändern Sie den Inhalt der angegebenen Datei `foobar` direkt:

.Buchstaben direkt ersetzen (Linux)
----
$ cat foobar
foo
$ sed -e 's/o/e/g' -i foobar
$ cat foobar
fee
$
----

Mit `BSD sed` unter OS X gibt es den Schalter `-i` auch. Hier versteckt
sich jedoch eine kleine Besonderheit im Aufruf. Mit dem Schalter muß auch
zwingend eine Erweiterung für die Backupdatei gegeben werden. Bleibt
diese leer, wird vor der Änderung keine Backupdatei erzeugt.

.Buchstaben direkt ersetzen (OS X)
----
$ cat foobar
foo
$ sed -e s/o/e/g -i '' foobar
$ cat foobar
fee
$
----

=== Mit Backupdatei ===

Gleiches erreichen Sie mit `GNU sed` auch. Möchten Sie eine Backupdatei
erzeugen, beachten Sie bitte, dass unter Linux zwischen dem Schalter
`-i` und der Erweiterung kein Leerzeichen stehen darf, `GNU sed` bei BSD
hingegen eines erwartet:

.Buchstaben direkt ersetzen und ein Backup erzeugen
----
$ cat foobar
foo
$ sed -e s/o/e/g -i.bak foobar
$ cat foobar
fee
$ cat foobar.bak
foo
$
----

== Modifizierten Inhalt in eine Datei speichern ==

`sed` verfügt über das Aktionsflag `w` gefolgt von einem Dateinamen, mit
dessen Hilfe Sie das Ergebnis ihrer Recherche oder Modifikation direkt
in eine Datei schreiben lassen können. Beachten Sie bei dem
nachfolgenden Beispiel, dass `sed` eine bestehende Datei mit dem
gleichen Namen `plz.dat` ohne Vorwarnung überschreibt, sofern diese
schon existiert.

.Ausgabe der Recherche in der Datei `plz.dat`
----
$ echo "10247 Berlin" | sed -E -n 's/([0-9]+) ([A-Za-z]+)/\2, \1/w plz.dat'
$ cat plz.dat
Berlin, 10247
$
----

== Danksagung ==

Vielen Dank an Thomas Osterried, Axel Beckert, Elmar Heeb, Wolfram
Schneider und Rebeka Catalina Trulsen für Kritik und
Verbesserungsvorschläge zum vorliegenden Tutorial.

== Weiterführende Dokumente ==

* [[[Barnett]]] Sed - An Introduction and Tutorial by Bruce Barnett, http://www.grymoire.com/Unix/Sed.html
* [[[Dougherty]]] Dale Dougherty: 'sed & awk', O'Reilly, http://shop.oreilly.com/product/9781565922259.do
* [[[Friedl]]] Jeffrey E. F. Friedl: 'Reguläre Ausdrücke', O'Reilly, http://shop.oreilly.com/product/9780596528126.do
* [[[Pement]]] Eric Pement: Useful One-Line Scripts For sed (Unix stream editor), http://sed.sourceforge.net/sed1line.txt
* [[[Wolf]]] Jürgen Wolf: 'Shell-Programmierung. Das umfassende Handbuch', Galileo Computing/Rheinwerk Verlag, ISBN 3-89842-683-1
* [[[Hofmann]]] Frank Hofmann: GitHub-Repo mit ausführlichen Beispielen, https://github.com/hofmannedv/training-shell

